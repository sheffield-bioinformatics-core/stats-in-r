---
title: "Statistical Analysis of Biological Data"
author: "Mark Dunning, Niamh Errington and Aya Elwazir"
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE)
```

# Acknowledgement

Some of these materials are based on previous courses at Cancer Research Uk Cambridge Institute.

- [Introduction to Statistical Analysis](http://bioinformatics-core-shared-training.github.io/IntroductionToStats/)
- [Further Statistical Analysis in R](https://rawgit.com/bioinformatics-core-shared-training/intermediate-stats/master/manual.pdf)

# Part I - Contingency tables

When working with categorical variables, we are usually interested in the frequencies of the different categories in our sample. To display data for two or more categorical variables, cross-tabulations, or contingency tables, are commonly used - with 2 x 2 tables being the simplest. We can then test whether there is an association between the row factor and the column factor by a *chi-squared test* or a *Fisher’s exact test*.

To demonstrate the analysis of contingency tables we will use a dataset provided with the `vcd` package. You will need to install this package using the R command


```{r eval=FALSE}
install.packages("vcd")
```


```{r}
library(dplyr)
library(ggplot2)
library(rstatix)
library(ggpubr)
```


The data frame `Arthritis` should then be accessible which is described as:- 

> Data from Koch & Edwards (1988) from a double-blind clinical trial investigating a new treatment for rheumatoid arthritis.

```{r}
#let's use the'Arthritis' dataset in the 'vcd' package 
library(vcd)
head(Arthritis)
```

The `count` function, included in `dplyr` can be used to give a tabulation of the values in any column in the data frame.

```{r message=FALSE}
##one way table (count of one variable)
count(Arthritis,Sex)
```

We can quickly visualise these counts as a *barplot*. A pie chart is possible, but not generally recommended.

```{r}
ggplot(Arthritis, aes(x = Sex)) + geom_bar()
```


Further manipulation of this table will give proportions (which will ultimately be used in the statistical testing)

```{r}
#to get proportion of males and females
count(Arthritis,Sex) %>% 
  mutate(prop = n / sum(n))
count(Arthritis,Sex) %>% 
  mutate(prop = n / sum(n), Percent = prop * 100)

```

The `count` function can also compare two columns from a data frame if both columns are given as arguments.

```{r}
count(Arthritis,Sex,Improved)
```

These can also be plotted 

```{r}
count(Arthritis,Sex,Improved) %>% 
ggplot(aes(x = Sex, fill = Improved, y = n)) + geom_col()
```


```{r}
count(Arthritis,Sex,Improved) %>% 
ggplot(aes(x = Sex, fill = Improved, y = n)) + geom_col(position = "dodge")
```

The same technique as before can be used to calculate the proportions, however this will calculate the proportion of the *whole dataset* which is probably not what we want.

```{r}
count(Arthritis,Sex, Improved) %>% 
  mutate(prop = n / sum(n))
count(Arthritis,Sex) %>% 
  mutate(prop = n / sum(n), Percent = prop * 100)

```

An extra `group_by` function can be used prior to the calculate of the proportions which allows the values be expressed as a proportion of the first or second variable.

```{r}
count(Arthritis,Sex, Improved) %>% 
  group_by(Sex) %>% 
  mutate(prop = n / sum(n),Percent = prop * 100)
```



A three-way table is also possible

```{r}
count(Arthritis,Sex,Improved,Treatment)

```
Having explored our data, we can now perform statistical testing. The function `chisq_test` can be used to assess whether differences in proportions are significant or not. We actually don't need to calculate the proportions; R will do this for us.

However, we need to re-format the data slightly into a *wide* table rather than the default *long* nature of a data frame in the `tidyverse`. We the `pivot_wider` function we create a two-by-two table that is typically used for a contingency analysis.

```{r}
Arthritis %>% 
  count(Improved, Treatment) %>% 
  tidyr::pivot_wider(values_from = n,names_from = Improved)

```

And now remove the `Treatment` column so that that data frame only has numeric data

```{r}
Arthritis %>% 
  count(Improved, Treatment) %>% 
  tidyr::pivot_wider(values_from = n,names_from = Improved) %>% 
select(-Treatment)  %>% chisq_test
```

However, the `chisq.test` function is not appropriate in all circumstances.

```{r}
Arthritis %>% 
  count(Improved, Sex) %>% 
  tidyr::pivot_wider(values_from = n,names_from = Improved) %>% 
select(-Sex)  %>% chisq_test
```

The Fisher test is recommended for tables with low numbers of observations (e.g. when more than 20% of cells have expected frequencies < 5)

```{r}
Arthritis %>% 
  count(Improved, Sex) %>% 
  tidyr::pivot_wider(values_from = n,names_from = Improved) %>% 
select(-Sex)  %>% fisher_test

```

<div class="alert alert-warning">

**Exercise**

1- Read the excel file called `Ex Biostat P1.xlsx` into R (see below for the required code)

2- Make a cross table showing the gender in the rows and tumor grade in the columns

3- Define the percentage of Grade III tumors within females 

4- Add a column in the table showing the sum of the 3 grades in males and in females and state the total number of males and females in the sample 

5- Use the appropriate test to check if the tumor grade depends on the gender 

```{r eval=FALSE}
## the readxl package is required to read xls and xlsx files into R
## However, csv and tsv files are recommended to store data

tab <- readxl::read_xlsx("data/EX Biostat P1.xlsx")

```

</div>




# Part II - How to assess normality

We will read some example data to illustrate how one would test for a normally-distributed variable. This property is important as it influences which test we should use.

One of the best ways of displaying data is by using a graph. Graphs can make both simple and complex data easier to understand by making it easier to spot trends and patterns. We can use plots to view the distribution of our data (minimum, maximum, mid-point, spread etc) and to ensure that the values in our dataset seem realistic (e.g. no outliers). Many statistical tests rely on the assumption that the data are normally distributed.

The data for this section are to be found in the file `normal_example.csv` in the `data` folder. You will need to specify the file path accordingly.

```{r message=FALSE}
library(readr)
df1 <- read_csv("data/normal_example.csv")
```

We can inspect the data in RStudio and discover that it consists of a single column called `x` that comprises numeric observations

```{r}
View(df1)
```

Various graphical methods are available to assess the distribution. The first of which is a *histogram*. Here, the data are split into "bins" (`ggplot2` chooses the number of bins) and the value on the `y` axis corresponds to the number of observations in that bin. The user only has to specify the variable to be plotted, and `ggplot2` takes care of the binning. From this plot we can judge what the average value of the data is, and the spread.

```{r}
gghistogram(df1,x="Value")
```


A similar option is to produce a density curve. Here the y-axis is the *density* of a particular value.

```{r}
ggdensity(df1, x="Value")
```

### Combining Histograms and Density 

When assessing the distribution of a variable, you might be tempted to plot the histogram and density on the same plot. `gghistogram` has the argument `add_density`, which should do the job.

```{r}
gghistogram(df1,x="Value",add_density = TRUE)
```

However, this doesn't work. If you check the y-axis limits on the histogram and density plots, you'll notice they are on a different scale. After some digging around the solution is [as follows](http://www.cookbook-r.com/Graphs/Plotting_distributions_(ggplot2)/)


```{r}
gghistogram(df1,x="Value",add_density = TRUE,y="..density..")
```

We can add the *standard* normal curve with the following:-

```{r}
gghistogram(df1,x="Value",add_density = TRUE,y="..density..") + stat_overlay_normal_density(col="steelblue")
```




A box plot is an excellent way of displaying continuous data when you are interested in the spread of your data. The box of the box plot corresponds to the lower and upper quartiles of the respective observations and the bar within the box, the median. The whiskers of the box plot correspond to the distance between the lower/upper quartile and the smaller of: the smaller/largest measurement *OR* 1.5 times the inter quartile range. A disadvantage of the box plot is that you don’t see the exact data points. However, box plots are very useful in large datasets where plotting all of the data may give an unclear picture of the shape of your data.

```{r}
## setting x to be empty is required to make a boxplot from one variable
ggboxplot(df1, y = "Value",x="Var")
```

A *violin plot* is sometimes used in conjunction with the boxplot to show density information.

```{r}
ggviolin(df1, x = "Var",y = "Value")
```

Individual points can also be added with `geom_jitter`; avoiding over-plotting by adding random noise along the x-axis.

```{r}
ggviolin(df1, x = "Var",y = "Value",add = "jitter")
```


Finally, we have a "*qq-plot*" which allows to compare the quantiles of our dataset against a theoretical normal distribution. If the majority of points lie on a diagonal line then the data are approximately normal.

```{r}
ggqqplot(df1, x="Value",facet.by = "Var")
```

These graphical methods are by far the easiest way to assess if a given dataset is normally-distributed.

For "real-life" data, the results are unlikely to give a perfect plot, so some degree of judgement and prior experience with the data type are required.  Indeed, it should be noted that the dataset visualised in the above plots was sampled from a normal distribution. Even then, the plots were not 100% convincing!

## Tests for normality

Although their usage is contentious amongst statisticians, there are a few methods for testing whether variables are normally-distributed or not. If the p-value is sufficiently small then we conclude that the data are not normally distributed. However, some statisticians prefer to use graphical methods and their intuition about the data or prior knowledge of the data type (e.g. some measures are generally believed to be normally-distributed)

```{r}

#shapiro test
#p<0.05 ...difference between data and normality..data not normal
#p>0.05 ...no diff between data and normality ..data normally distributed

df1 %>% 
  group_by(Var) %>% 
shapiro_test(Value) %>% 
  mutate(p < 0.05)

```

## Descriptive Statistics

In the [accompanying R course](http://sbc.shef.ac.uk/r-crash-course/) we have seen how to produce summary statistics of columns in a dataset. For a dataset that is normally-distributed, appropriate measures of the average and variability are the *mean* and *standard deviation*. Both these functions are available within R and can be used in conjunction with the `summarise` function in `dplyr`.

```{r}
df1 %>% 
  group_by(Var) %>% 
  get_summary_stats
```

<div class="alert alert-warning">
**Exercise**

1- Read the excel file called `Ex Biostat P2.xlsx` into R 

2- Identify if the age and hospitalization days are normally distributed

3- Use the appropriate descriptive statistics [mean and SD,  or median and IQR] for each variable

</div>



# Part III - Significance tests for continuous variables

In this part we will show how to perform tests to compare 1, 2 (or more) continuous variables. The dataset, provided by MASH at The University of Sheffield, describes individuals that have been following different diets and their age and gender. The main goal of interest is to determine which of three competing diet regimes results in the greatest weight loss. However, we can use the dataset to demonstrate other types of test.

```{r message=FALSE}
diet <- read_csv("data/diet.csv")
diet
```



## One-sample test

The first hypothesis we will test is whether the people in the study are overweight or not. This first involves some manipulation of the table to calculate an extra variable; the Body Mass Index (BMI). We will test if people in our study are overweight, where overweight is defined as having a BMI over 25.

$BMI = weight  / height^2$

(*where the weight is measured in kg, and the height in metres*)

<div class="alert alert-warning">
**Exercise**

- Add a new variable to the data frame for the BMI of each person 
    + you might want to do this in multiple steps using the `%>%` notation
</div>

```{r echo=FALSE}
diet <- diet %>% 
  mutate(BMI =initial.weight / (height/100)^2)

```

We can now test our new variable for normality using the plots and tests from earlier

```{r eval=FALSE}
ggplot(diet, aes(x = BMI)) + geom_histogram(aes(y=..density..)) + stat_overlay_normal_density(col="steelblue")

```

The one-sample t-test is implemented in the function `t.test`. The only input we need to specify is a *vector* of numeric values and it will perform a statistical test. For simplicity, we can use the `$` notation in R to extract the column. This will provide us with a *t* test statistic and a p-value. **However, it is up to us to interpret the p-value**.

```{r}
diet %>% 
  t_test(BMI ~1)
```

We get a significant result! However, if we look at the description for `t.test` it is testing against a population mean of $0$. It is no surprise that we get a significant result! By changing the `mu` argument we can perform a test to see if the people in the study are overweight to begin with (using 25 as the population or known mean).

```{r}
diet %>% 
  t_test(BMI ~1,mu = 25,alternative = "greater")
## 25 is the cutoff for overweight
#t.test(diet$BMI, mu=25,alternative = "greater")
```


##  Two-sample tests

A two-sample t-test should be used if you want to compare the measurements of two populations. There are two types of two-sample t-test: independent (unpaired) and paired (dependent). To make the correct choice, you need to understand your underlying data. 

An independent two-sample t-test is used when the two samples are independent of each other, e.g. *comparing the mean response of two groups of patients on treatment vs. control in a clinical trial*. 

As the name suggests,a paired two-sample t-test is used when the two samples are paired, e.g. *comparing the mean blood pressure of patients before and after treatment* (two measurements per patient).

Back to our dataset, we might wonder if there is actually any effect due to diet. 

```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  ggplot(aes(x = Time, y = Weight)) + geom_boxplot()
```



```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  group_by(Time) %>% 
  shapiro_test(Weight)
```


```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  t_test(Weight ~ Time)
```


```{r}
t.test(diet$final.weight, diet$initial.weight)
```

The p-value is significant and shows that overall the weights of individuals is *different* before and after diet. However, this test is not specifically testing for a *decrease* after the diet (which we would really hope to be the case). By adding an extra argument `alternative=less` we get a different result

```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  t_test(Weight ~ Time,alternative = "less")
```


```{r}
t.test(diet$final.weight, diet$initial.weight,alternative = "less")
```

```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  ggplot(aes(x = Time, y = Weight)) + geom_boxplot() + geom_jitter(width=0.1) + stat_compare_means(method = "t.test",method.args = list(alternative = "less"))
```


There is also extra information that we could employ; namely that the measurements of weight are made **on the same person** before and after dieting. This is a classic example of when to apply a paired t-test. Again, we do not need to use a different function to perform the test; only add an argument `paired=TRUE` to `t_test`.

```{r}
diet %>% 
  select(contains("weight")) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  t_test(Weight ~ Time,alternative = "less",paired=TRUE)
```


```{r}
t.test(diet$final.weight, diet$initial.weight,alternative = "less", paired=TRUE)
```

The output of the test is quite informative as it suggest that testing has been performed on sets of differences. In actual fact, this is the same as performing  a *one-sample test* on the differences we have already calculated:-

```{r}
diet <- mutate(diet, weight.loss = final.weight - initial.weight)
```


```{r}
diet %>%  
  t_test(weight.loss ~ 1,alternative = "less")
```
A convenient plot in `ggpubr` will allow us to visualise the paired differences

```{r}
ggpaired(diet, cond1="initial.weight", cond2="final.weight",line.color = "grey") + stat_compare_means(paired=TRUE,method = "t.test")
```


## The Independent t test, with two independent groups 

Lets consider that we want to compare whether males or females lost more weight during the trial. Here we have two groups and these can be treated as *independant* variables as different patients belong to the two groups.

The *null hypothesis* for such a test would be that the weight loss is the same between groups male and female. We seek to evidence to reject this hypothesis by calculating a test statistic. Firstly, we have to check for normality:-

```{r}
diet %>% 
ggdensity("weight.loss",color = "gender") + stat_overlay_normal_density()

diet %>%  
  group_by(gender) %>% 
  shapiro_test(weight.loss)
  
```

We conclude that the variances are approximately the same and both variables are normally-distributed


We can now use the `t_test` function to perform an *independant* test. The first argument to `t_test` is the *R formula* notation for the test being performed. It allows us to define which columns in our dataset are the numeric and grouping variables in the test.

This function allows various type of test to be performed by changing the appropriate arguments (see the help for `t.test` for details (`?t.test`)). For instance, we can tell the test that we believe our variances are equal or not.


```{r}
diet %>% 
  t_test(weight.loss ~ gender)
```


We can see that the t-statistic we observe is consistent with the null hypothesis, that the weight loss in males and females is the same. That is, the probability of observing a t-statistic of 0.2 or more, or -0.2 or less, is quite high.

*This is not a significant result (p>0.05), so there is no evidence of a difference in weight loss between males and females*

```{r}
diet %>% 
  ggplot(aes(x = gender, y=weight.loss)) + geom_boxplot() + stat_compare_means(method="t.test")
```

## Non- Parametric alternatives (e.g. the Wilcoxon test)

Being able to use the `t-test` relies on the your data being normally-distributed. If we do not sufficient confidence in this assumption, there are different statistical tests that can be applied. Rather than calculating and comparing the *means* and *variances* of different groups they are *rank-based* methods. However, they still come with a set of assumptions and involve the generation of test statistics and p-values.

### Independent samples = Wilcoxon rank sum test (Mann Whitney U test)

This test has many different names including the Wilcoxon, Wilcoxon two sample test, Wilcoxon-Mann-Whitney, Wilcoxon rank sum and the Mann-Whitney-U test. However, this test should not be confused with the Wilcoxon signed rank test (which is used for paired tests). To avoid confusion this test is usually referred to as the Mann-Whitney U test, which is used when the dependent variable to be examined is continuous but the assumptions for parametric tests are violated.

The assumptions of the Mann-Whitney U are as follows:

1.The dependent variable is ordinal or continuous.

2.The data consist of a randomly selected sample of independent observations from two independent groups.

3.The dependent variables for the two independent groups share a similar shape.

Fortunately, the R developers have made the function to do a Wilcox-test similar to doing a t-test. **The difficulty is in choosing the correct test to apply - which R will not advise you on**.

Let's go back to our example of comparing weight loss between groups male and female. The equivalent non-parametric version of the test we performed before is:-

```{r}
diet %>% 
  wilcox_test(weight.loss ~ gender)
```

The `wilcox_test` is flexible in much the same way that `t_test` in. We can switch to applying a paired test by adding the argument `paired=TRUE`.

```{r}
diet %>% 
  select(initial.weight,final.weight) %>% 
  tidyr::pivot_longer(everything(),values_to = "Weight",names_to = "Time") %>% 
  wilcox_test(Weight ~ Time, paired=TRUE)
```


## Compare between *more than two* groups

#### Parametric (ANOVA)

The two-sample t-test is useful when we have just two groups of continuous data to compare. When we want to compare more than two groups, a one-way ANOVA can be used to simultaneously compare all groups, rather than carrying out several individual two-sample t-tests.  The main advantage of doing this is that it reduces the number of tests being carried out, meaning that the type I error rate (the probability of seeing a significant result just by chance) does not become inflated. 

In order to justify if an ANOVA test is appropriate we have to test for normality.

```{r}


diet %>%   
ggplot(aes(x = diet.type, y = weight.loss)) + geom_violin()
group_by(diet, diet.type) %>% 
  shapiro_test(weight.loss)
```

A one-way ANOVA compares group means by partitioning the variation in the data into *between group variance* and *within group variance*. Like the other statistical tests we have encountered, the functions in R do the hard work of calculating the statistics. Performing the analysis is in two stages; fit the model using the `aov` function and then assess the significance using the `summary` function

```{r}
diet %>% 
  anova_test(weight.loss ~ diet.type)
```


When the test provides a significant result it tells us that there is at least on difference in the groups. However, it does not tell us which group is different. For this, we can apply a "post-hoc test" such as the Tukey test. If `summary(anova)` did not produce a significant p-value, we wouldn't proceed with this step

```{r}
diet %>% 
  tukey_hsd(weight.loss ~ diet.type)
```



```{r}
TukeyHSD(anova)
```

```{r}
my_comparisons <- list( c("A", "B"), c("A", "C"), c("B", "C") )

ggplot(diet, aes(x = diet.type, y = weight.loss)) + geom_violin() + stat_compare_means(method = "t.test",comparisons = my_comparisons)
```
```{r}
stat_res <- diet %>% 
  tukey_hsd(weight.loss ~ diet.type)

ggplot(diet, aes(x = diet.type, y = weight.loss)) + geom_violin() + stat_pvalue_manual(stat_res, label = "p.adj",y.position = c(5, 10, 15))
```



### Non-Parametric (Kruskal Wallis) 

Data that do not meet the assumptions of ANOVA (e.g. normality) can be tested using a non-parametric alternative. The *Kruskal-Wallis* test is derived from the one-way ANOVA, but uses ranks rather than actual observations. It is also the extension of the Mann-Whitney U test to greater than two groups.

```{r}
diet %>% 
  kruskal_test(weight.loss ~ diet.type)
```


```{r}
kruskal.test(weight.loss ~ as.factor(diet.type), data=diet)
```

Like the one-way ANOVA this will only tell us that at least one group is different and not specifically which group(s). The post-hoc `dunn.test` is recommended which also performs multiple testing correction.
```{r}
diet %>% 
  dunn_test(weight.loss ~ diet.type)
```



```{r}
library(dunn.test)
dunn.test(diet$weight.loss,diet$diet.type,method = "Bonferroni")
```

At this point we could be about to recommend diet C to those that wish to lose weight. However, are there any other factors in the data that we should be considering? With `ggplot2` we can quite easily visualise the effects of multiple factors on the data. Lets add both gender and diet type into the plot. It now appears that diet C is having an effect on males but not females.

```{r}
ggplot(diet, aes(x = diet.type, y = weight.loss,fill=gender)) + geom_boxplot()
```

## Two-way ANOVA

The *formula* notation allows us to specify an *interaction* between gender and diet type. In other words, we are looking to see if the effect of diet type is different for males and females.

```{r}
diet %>% 
  anova_test(weight.loss ~ diet.type*gender)
```


```{r}
anova <- aov(weight.loss ~ diet.type*gender, data=diet)
summary(anova)
```

This tells us that an effect exists between diet type and gender, but like before we have to run a post-hoc test to discover more

```{r}
diet %>% 
  tukey_hsd(weight.loss ~ diet.type*gender)
```


```{r}
TukeyHSD(anova)
```

```{r}
TukeyHSD(anova)

```


## Repeated Measures

We will read a modified version of the diet dataset in order to test a "repeated measures" analysis. Here we have added a midpoint weight measurement.

```{r}
diet2 <- read_csv("data/diet2.csv")
View(diet2)
```

However, the three measures that we want to compare are given as columns in the data frame. We cannot express this using the R `~` notation. In other words the data is in *wide* format and not *long*. We can change this using the `tidyr` package. This creates a variable for the type of measurement (`initial`, `mid` or `final)` and a variable containing the corresponding value. The default column names are `name` and `value` respectively.

```{r}
### With "::" you can use a function from a package you haven't loaded yet

diet_melt <- diet %>% select(contains("weight")) %>% 
  tidyr::pivot_longer(1:3)
```

```{r}
summary(aov(value~name,data=diet_melt))
```





<div class="alert alert-warning">
**Exercise**

The excel file ‘RCC2’ contains data about the expression levels of some genes in patients with renal cell carcinoma. In your study, you put the following hypotheses.
Please test those alternative hypotheses and state whether you will accept or reject each one.

1.	Females have a higher level of E2F3 than males 
2.	ANXA expression levels vary between unilateral and bilateral tumors
3.	Individuals with RCC grade II have different levels of E2F3 than those with grade III or IV 
4.	The mean value of miR499 decreases significantly after treatment
5.	DFFA is higher in patients with grade IV tumors
</div>

# Solutions

**To be revealed during the workshop!**

